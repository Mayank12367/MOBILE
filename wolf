Write a program to store the elements in 1-D array and perform the operations
like searching, sorting and reversing the elements. [Menu Driven]
def display_menu():
 print("1. Add element to the array")
 print("2. Search for an element")
 print("3. Sort the array")
 print("4. Reverse the array")
 print("5. Display the array")
 print("6. Exit")
def add_element(arr, element):
 arr.append(element)
 print(f"{element} added to the array")
def search_element(arr, element):
 if element in arr:
     return f"{element} found at index {arr.index(element)}"
 else:
     return f"{element} not found in the array"
def sort_array(arr):
 arr.sort()
 print("Array sorted")
def reverse_array(arr):
 arr.reverse()
 print("Array reversed")
def display_array(arr):
 print("Array:", arr)
if __name__ == "__main__":
    array = []
    while True:
          display_menu()
          choice = input("Enter your choice: ")
          if choice == "1":
              element = int(input("Enter the element to add: "))
              add_element(array, element)
          elif choice == "2":
             element = int(input("Enter the element to search: "))
             result = search_element(array, element)
             print(result)
          elif choice == "3":
             sort_array(array)
          elif choice == "4":
             reverse_array(array)
          elif choice == "5":
             display_array(array)
          elif choice == "6":
             print("Exiting the program.")
             break
          else:
             print("Invalid choice. Please try again.")



Read the two arrays from the user and merge them and display the elements in
sorted order. [Menu Driven]
def display_menu():
 print("1. Enter elements for Array 1")
 print("2. Enter elements for Array 2")
 print("3. Merge and sort arrays")
 print("4. Display merged and sorted array")
 print("5. Exit")
def merge_and_sort(arr1, arr2):
 merged_array = arr1 + arr2
 merged_array.sort()
 return merged_array
if __name__ == "__main__":
 array1 = []
 array2 = []
 while True:
     display_menu()
     choice = input("Enter your choice: ")
     if choice == "1":
         elements = input("Enter elements for Array 1 (comma-separated): ").split(',')
         array1 = [int(element.strip()) for element in elements]
         print("Array 1 updated.")
     elif choice == "2":
         elements = input("Enter elements for Array 2 (comma-separated): ").split(',')
         array2 = [int(element.strip()) for element in elements]
         print("Array 2 updated.")
     elif choice == "3":
         merged_and_sorted = merge_and_sort(array1, array2)
         print("Arrays merged and sorted.")
     elif choice == "4":
         if not merged_and_sorted:
              print("Please merge and sort the arrays first (Option 3).")
         else:
              print("Merged and sorted array:", merged_and_sorted)
     elif choice == "5":
         print("Exiting the program.")
         break
     else:
         print("Invalid choice. Please try again.")



BUBBLE SORT
def BubbleSort (alist):
 for i in range (len (alist) -1,0,-1):
  for j in range(i):
       temp=alist[j]
       alist[j]=alist[j+1]
       alist[j+1]-temp 
alist=[]
n=int(input ("Enter the no. of elements :")) 
while (n>0): 
 x=int (input ("Enter the elements :")) 
 alist.append(x) 
 n=n-1 
BubbleSort (alist) 
print (alist)



INSERTION SORT
def InsertionSort (alist):
 for i in range (1, len (alist)):
     temp=alist [i] 
     hole=i
     while hole>0 and alist [hole-1]>temp:
        alist [hole]=alist[hole-1] 
        hole=hole-1 
        alist [hole]-temp 
alist=[] 
n=int (input ("Enter the no.of elements :")) 
while (n>0): 
   x=int(input("Enter the elements :")) 
   alist.append(x)
   n=n-1
InsertionSort (alist) 
print (alist)



Quick Sort
def quicksort (alist, start, end): 
 if startkend:
    loc=partition (alist, start, end) 
    quicksort (alist, start, loc) 
    quicksort (alist, loc+1, end) 
def partition (alist, start, end): 
   pivot=alist [start] 
   left=start+1 
   loc=end 
   flag=0 
   while flag!=1:
     while left<= loc and alist[left]<=pivot: 
        left=left+1 
     while alist [loc]>=pivot and loc>=left: 
        loc=loc-1 
     if lock<left: 
       flag=1 
     else:
       temp=alist [left] 
       alist [left]=alist [loc] 
       alist[loc]=temp 
     temp=alist[start] 
     alist [start]=alist [loc] 
     alist [loc]=temp 
     return loc 
alist=[] 
n=int(input("Enter the number of elements")) 
while (n>0): 
  x=int(input("Enter the elements:")) 
  alist.append(x) 
  n=n-1 
print ("Original list:",alist) 
quicksort (alist, 0, len (alist)-1) 
print ("Sorted List", alist)


Merge sort
def mergeSort (alist): 
  print ("Dividing", alist) 
  if len (alist)>1: 
    m=len (alist)//2 
    L=alist [:m] 
    R=alist [m:] 
    mergesort (L) 
    mergeSort (R) 
    i=0
    j=0
    k=0
    while i<len (L) and j<len (R): 
      if L[i] < R[j]: 
        alist [k]=L[i] 
        i=i+1 
      else: 
        alist [k]=R[j] 
        j=j+1 
      k=k+1 
      while i<len (L): 
        alist [k]=L[i] 
        i=i+1 
        k=k+1 
      while i<len (L): 
        alist [k]=L[i] 
        j=j+1 
        k=k+1 
alist=[77,22,55,33,11] 
mergeSort (alist) 
print (alist)


4)IMPLEMENT USE OF SETS AND VARIOUS OPERATIONS ON SETS
set1=set()
print("Initial set is empty:", set1)
set1.add("red")
print("After adding 1 element:", set1)
set1.update(["yellow", "blue"])
print ("After updating more elements:",set1)
if "red"in set1:
    set1.remove("red")
print ("After removing (red) elements:", set1)
print (set1)
for item in set1:
  print (item)
print ("Item count:",len (set1))
isempty=len(set1)==0
set1= set(["red", "yellow"])
set2=set(["blue", "yellow"])
set3=set1&set2
set4=set1|set2
set5=set1-set2
set6=set1^set2
issubset=set1<=set2
superset=set1>=set2
set7=set1.copy()
set7.remove("red")
set8=set1.copy()
set8.clear()
print ("Original set:", set1)
print ("Original set:", set2)
print ("Intersection of setlist2:",set3)
print("Union set1|set2:",set4)
print("set diference (set1-set2)", set5)
print("symetric difference (set1^set2):",set6)
print("Subset test (set1<=set2)):",issubset)
print("Superset text(set1>=set2):",superset)
print("Shallow copy:", set7)
print("After clearing:",set8)


5)IMPLEMENT WORKING OF STACKS
Mystack=[]
stacksize=3
def Displaystack():
   print ("stack currently contains ")
   for item in Mystack:
     print (item)
def push (value):
   if len(Mystack)<stacksize:
       Mystack.append(value)
   else:
       print ("STACK IS FULL")
def pop():
    if len(Mystack)>0:
        Mystack.pop()
    else:
        print ("STACK IS EMPTY")
push (1)
push (2)
push (3)
Displaystack()
input ("Press any key when ready..")
push (4)
Displaystack()
input ("Press any key when ready.. ")
pop()
Displaystack()
input ("Press any key when ready..")
pop ()
pop ()
pop ()
Displaystack()



QUEUE
A(A QUEUE IS A LIST OF ITEMS WHICH YOU ADD AND DELETE ITEMS FROM)
class Queue:

  def  __init__(self):
      self.items=[]

  def isEmpty(self):
      return self.items == []

  def enqueue (self, item):
      self.items.insert(0, item)

  def dequeue(self):
      return self.items.pop()

  def size (self):
      return len(self.items)

q= Queue()

q.enqueue("hello")

q.enqueue ('dog')

q.enqueue (3)

q.dequeue()

q.enqueue (4)

q.enqueue ('Nero')
q.enqueue("Dante")

q.enqueue(True)
print (q.size())


8
A)SINGLY LINKED LIST
class Node (object ):
    def __init__(self, data, next):
        self.data=data
        self.next=next
class SingleList (object):
 head=None
 tail=None
 def show (self):
   print("showing list data")
   current_node=self.head
   while current_node is not None:
       print (current_node.data, "->")
       current_node=current_node.next
   print (None)
 def append(self, data):
     node=Node (data, None)
     if self.head is None:
        self.head=self.tail=node
     else:
        self.tail.next=node
        self.tail=node
 def remove(self,node_value):
     current_node=self.head
     previous_node=None
     while current_node is not None:
         if current_node.data==node_value:
             if previous_node is not None:
                 previous_node.next=current_node.next
             else:
                 self.head=current_node.next
         previous_node=current_node
         current_node=current_node.next
s=SingleList()
s.append(31)
s.append(2)
s.append(3)
s.append(4)
s.show()


9)IMPLEMENT BINARY TREE AND ITS TRANSVERSALS
class node:
   def __init__(self, key):
       self.left=None
       self.right=None
       self.val=key
def printInorder(root):
    if root:
       printInorder(root.left)
       print(root.val)
       printInorder(root.right)
def printPostorder(root):
    if root:
        printPostorder(root.left)
        printPostorder(root.right)
        print(root.val)
def printPreorder(root):
    if root:
        print(root.val)
        printPreorder(root.left)
        printPreorder (root.right)
root=node(1)
root.left=node(2)
root.right=node(3)
root.left=node(4)
root.right=node(5)

print("Print Preorder transversal of binary tree", printPreorder(root))
print("\n Print Inorder transversal of blanary tree",printInorder(root))
print("\n Print Postorder transversal of binary tree",printPostorder(root))
